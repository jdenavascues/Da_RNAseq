---
title: "Visualisation of DESeq2 results"
description: "DEG analysis based on DESeq2 and GSEA"
principal investigator: "Joaquín de Navascués"
researcher: "Aleix Puig, modified by Joaquín de Navascués"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: readable
    df_print: paged
---
```{r set-publication-theme, echo=FALSE, cache=FALSE}
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
```

```{r setup, echo = FALSE, cache = FALSE}
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'), 
                      fig.align = 'center', fig.height = 5, fig.width = 8.5, 
                      pdf.options(encoding = "ISOLatin9.enc"),
                      fig.path='integration/figures/', warning=FALSE, message=FALSE)
```

**Libraries needed:**

Installed, not loaded: ??????????

Loaded:

```{r, include=FALSE}
# data
library(tibble)
library(stringr)
library(purrr)         # map
library(DescTools)     # outside operator
library(dplyr)         # filter
# library(genefilter)
# graphics
library(ggplot2)
library(ggthemes)       # italics in the figures
library(ggtext)         # italics in the figures
library(pheatmap)       # pretty heatmap
library(dendsort)       # to sort dendrograms
library(scico)          # scientific colormaps
library(ggrepel)        # to avoid overlapping text
library(cetcolor)       # Peter Kovesi's perceptually uniform colour maps
# convenience
library(here);
setwd(here())
```

# RNAseq results visualisation: Samples heatmap

## 1 Gather the DEG data

```{r}
# experimental design and labels
targets <- readRDS('output/targets.RDS')
# add column to distinguish control batches
targets$sample_type <- targets$Condition
targets$sample_type[targets$sample_type=='Control'] <- str_c(
  targets$Condition, "_", targets$Batch)[targets$Condition=='Control']
targets[,c('Condition', 'sampleIDs', 'sample_type')]
```

```{r}
# TPM counts
tpmNormalisedCounts <- readRDS('output/tpmNormalisedCounts.RDS')
# pseudocounts
vsd_bcorr <- readRDS('output/vst_pseudocounts_batchCorrected.RDS')
# DEG lists
data_list <- list.files("output", pattern = "_vs_")
datasets <- pmap(list(file = paste("output", data_list, sep = "/")),
                 readRDS)
names(datasets) <- str_split_fixed(
  str_split_fixed(data_list, ".RDS", n=2)[,1],
  "_", n=3)[,3]
```

Total unique differentially expressed genes for | log2FC | > 2:
```{r}
# Filter for DEG with abs(log2FC) >= `fc_thresh`
fc_thresh <- 3
DE_genes <- datasets %>% 
  map( filter, padj <= 0.05 ) %>%
  map( filter, log2FoldChange %][% c(-fc_thresh, fc_thresh) )
# get the union of DEGs sets
DE_unique_genes <- unique(unlist(lapply(DE_genes, '[[', "ensemblGeneID")))
length(DE_unique_genes)
```

## 2 Using TPM counts with and without batch-correction

Let us first try to use the data as 'raw' as possible: TPM-normalised counts, Z-scored (as the range of values is 0.2 - 10,000) - obviously with no batch correction.

```{r}
# make rownames a column to filter by DEGs
tpmNormalisedCounts$EnsemblGeneID <- rownames(tpmNormalisedCounts)
DE_tpm <- tpmNormalisedCounts[match(DE_unique_genes, tpmNormalisedCounts$EnsemblGeneID),]
DE_tpm <- subset(DE_tpm, select = -EnsemblGeneID) # removes rownames column
```

This gets us the TPMs of all DEGs, without Z-scoring -- this is done internally in the `pheatmap` function).

Prepare the heatmap customisation:
```{r}
main.title <-  'Clustered heatmap of DEGs'
# annotation labels
## for batch
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
                                         yes = '1',
                                         no =  '2'))
## for genotype
ann_labels <- data.frame(batch = ifelse(test = targets$Batch == 'a',
                                         yes = '1',
                                         no =  '2'))
ann_labels$condition <- plyr::mapvalues(targets$Condition,
                                       from=unique(targets$Condition),
                                       to=c('da RNAi', 'da ov/ex',
                                            'control', 'da:da ov/ex',
                                            'scute ov/ex'))
ann_labels$condition <- factor(ann_labels$condition,
                               levels=c('da RNAi', 'control',
                                        'da ov/ex', 'da:da ov/ex',
                                        'scute ov/ex'))
rownames(annot_batch) <- targets$sampleIDs # same as `names(DE_tpm)`
# annotation colours
ann_colors = list(
  batch = c('1' = RColorBrewer::brewer.pal(12, 'Paired')[2],
            '2' = RColorBrewer::brewer.pal(12, 'Paired')[8]),
  condition = c("da RNAi" = RColorBrewer::brewer.pal(12, 'Paired')[9],
                "da ov/ex" = RColorBrewer::brewer.pal(12, 'Paired')[5],
                "control" = RColorBrewer::brewer.pal(12, 'Paired')[1],
                "da:da ov/ex" = RColorBrewer::brewer.pal(12, 'Paired')[6],
                "scute ov/ex" = RColorBrewer::brewer.pal(12, 'Paired')[4])
  )
```



```{r, fig.height=8, fig.width=10}
hm <- pheatmap(
  # data
    mat               = DE_tpm,
    scale             = "row",   # z-scores the rows
  # main
    main              = main.title,
    fontsize          = 14,
    clustering_method = "ward.D2",
    #annotation        = ann_labels,
    annotation    = dplyr::select(ann_labels, condition),
  # rows
    cluster_rows      = TRUE,
    clustering_distance_rows = 'correlation',
    treeheight_row    = 25,      # default is 50
    show_rownames     = FALSE,
  # cols
    cluster_cols      = TRUE,
    clustering_distance_cols = 'correlation',
    treeheight_col    = 25,
    show_colnames     = TRUE,
    labels_col        = targets$sample_type,
    fontsize_col      = 9,
    angle_col         = 45,
  # legends
    annotation_colors = ann_colors,
  # tiles
    color             = cet_pal(n = 256, name = "cbd1", alpha = 1),
    border_color      = NA,
    cellwidth         = 20,
    cellheight        = 0.5
)
hm
```
Note that for a 'publication' customised plot, it will probably be better to go the `ggplot2` route using [this approach](https://jcoliver.github.io/learn-r/008-ggplot-dendrograms-and-heatmaps.html) or [this one](https://stackoverflow.com/questions/36852101/r-legend-title-or-units-when-using-pheatmap).

Some tips for further modifying the `pheatmap` output are [here](https://stackoverflow.com/questions/33292067/pheatmap-annotation-colors-and-border).























```{r}
# get the TPM average per gene per condition
means_DE <- data.frame(matrix(nrow=length(DE_unique_genes), ncol = 0))
for ( stype in unique(targets$sample_types) ) {
  means_DE <- cbind(means_DE, (rowMeans(
    DE_tpm[, targets$sampleIDs[targets$sample_types==stype] ] )))
}
colnames(means_DE) <- unique(targets$sample_types)
###

zscore_DE <- data.frame(matrix(nrow=length(DE_unique_genes), ncol = 0))

# choose to use all samples or the mean of the replicates for each sample
var1 <- DE_tpm














```



```{r}

vsd <- assay(vst(dds))
Z <- t(scale(t(vsd)))


```














## Using pseudocounts with batch-correction
No need to do Z-scoring or any other normalisation here?? the range of values is ~ 5-22

(What would be the point of doing that *without* batch correction)

https://hbctraining.github.io/GCC-BOSC-2018/lessons/data_visualization.html


















Plot the tpm values

```{r}
relative_Significant_Genes <- sortedFinalData_named_KD %>% 
  filter(padj <= 0.01) %>%
  filter(log2FoldChange >= 1 | log2FoldChange <= -1) %>%
  dplyr::select(external_gene_name, starts_with("TPM")) %>%
  column_to_rownames(var="external_gene_name") %>%
  data.matrix()

#heatmap(heatmap_prep)


vsd <- assay(vst(dds))
Z <- t(scale(t(vsd)))

```

