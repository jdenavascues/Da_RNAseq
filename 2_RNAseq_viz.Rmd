---
title: "Visualisation of DESeq2 results"
description: "DEG analysis based on DESeq2 and GSEA"
principal investigator: "Joaquín de Navascués"
researcher: "Aleix Puig, modified by Joaquín de Navascués"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: readable
    df_print: paged
---
```{r set-publication-theme, echo=FALSE, cache=FALSE}
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
```

```{r setup, echo = FALSE, cache = FALSE}
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'), 
                      fig.align = 'center', fig.height = 5, fig.width = 8.5, 
                      pdf.options(encoding = "ISOLatin9.enc"),
                      fig.path='integration/figures/', warning=FALSE, message=FALSE)
```

```{r, include=FALSE}
# data
library(tibble)
# graphics
library(ggplot2)
library(ggthemes)       # italics in the figures
library(ggtext)         # italics in the figures
library(pheatmap)       # pretty heatmap
library(scico)          # scientific colormaps
library(ggrepel)        # to avoid overlapping text
# convenience
library(here);
setwd(here())
```

# 1 Heatmap of clustered samples and genes

We have their "transcripts per million" (tpm) in different RDS files.
```{r}

```



# https://hbctraining.github.io/GCC-BOSC-2018/lessons/data_visualization.html







# 1 Principal Components Analysis

## 1.1. PCA of the batches separately

### 1.1.1 _da_ overexpression and knock-down

Include the whole dataset (as opposed to only the genes with significant DE).
```{r}
# get the data (fresh session)
targets <- readRDS('output/targets.RDS')
tpmNormalisedCounts <- readRDS('output/tpmNormalisedCounts.RDS')
# remove all rows that have no variance
tpmNormalisedCounts_pca <- tpmNormalisedCounts[
  rowSums(tpmNormalisedCounts[-1] != tpmNormalisedCounts[[2]], na.rm = TRUE) != 0, ]
# same for the other count datasets
normalisedCounts <- readRDS('output/normalisedCounts.RDS')
normalisedCounts_pca <- normalisedCounts[
  rowSums(normalisedCounts[-1] != normalisedCounts[[2]], na.rm = TRUE) != 0, ]
rawCounts <- readRDS('output/rawCounts.RDS')
rawCounts_pca <- rawCounts[
  rowSums(rawCounts[-1] != rawCounts[[2]], na.rm = TRUE) != 0, ]

```

### PCA object
```{r}
pca <- prcomp(t(tpmNormalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
summary(pca)
```
### Create QC plot
```{r}
ggplot(scores,
       aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
       ) +
  geom_point(size=4) +
  geom_point(size=2, colour='white', alpha=0.8) + 
  geom_text_repel(size=4, max.overlaps=Inf, 
                  force_pull = -0.03, seed=42,
                  box.padding = 0.5,
                  point.padding = 0.5) +
  scale_colour_discrete(name="condition") +
  theme_bw() +
  lims(x= c(-115, 175), y = c(-70, 70)) +
  theme(legend.text=element_markdown(size=9))
```

```{r}
pca <- prcomp(t(normalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
ggplot(scores,
       aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
       ) +
  geom_point(size=4) +
  geom_point(size=2, colour='white', alpha=0.8) + 
  geom_text_repel(size=4, max.overlaps=Inf, 
                  force_pull = -0.03, seed=42,
                  box.padding = 0.5,
                  point.padding = 0.5) +
  scale_colour_discrete(name="condition") +
  theme_bw() +
  theme(legend.text=element_markdown(size=9))
```
```{r}
pca <- prcomp(t(rawCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
ggplot(scores,
       aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
       ) +
  geom_point(size=4) +
  geom_point(size=2, colour='white', alpha=0.8) + 
  geom_text_repel(size=4, max.overlaps=Inf, 
                  force_pull = -0.03, seed=42,
                  box.padding = 0.5,
                  point.padding = 0.5) +
  scale_colour_discrete(name="condition") +
  theme_bw() +
  theme(legend.text=element_markdown(size=9))
```



ok, what have I learned so far:
- the batch correction is applied only, apparently, to the PSEUDOCOUNT data normalised with VST (vsd) variance stabilizing transformation (which should be run with blind=FALSE!!!!)
- this can be used directly (in principle) for heamapping, as it reduces the variance.
- so if we try to do TPM (not batch-corrected), z-transform, and heat mapping, we may be displaying mostly batch effects
things to test:
- try heatmap of TPM z-scores anyway.
- re-do the VST transform with blind=FALSE for the definitive PCA plots
- try the limma::removeBatchEffect command directly on the TPM data (log2 transformed!), then re-transform into TPM, z-score, plot.
  Repeat this with normalised counts.
  I wonder what is the point of using TPM and not simply pseudocounts after all these transformations.
  







































### 1.1.2 _da:da_ and _scute_ overexpression

Include the whole dataset (as opposed to only the genes with significant DE).
```{r}
targetsB2 <- read.table("resources/targets_dadasc.txt", header=TRUE, sep="\t")
tpmNormalisedCountsB2 <- readRDS('dadasc_counts.RDS')
# remove all rows that have no variance
tpmNormalisedCountsB2_pca <- tpmNormalisedCountsB2[
  rowSums(tpmNormalisedCountsB2[-1] != tpmNormalisedCountsB2[[2]], na.rm = TRUE) != 0,
  ]
```

### PCA object
```{r}
pca <- prcomp(t(tpmNormalisedCountsB2_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targetsB2$sampleID, pca$x[,1:2])
summary(pca)
```
### Create QC plot
```{r}

# USE GGREPEL HERE!!!

targetsB2$Condition[targetsB2$Condition=='DaDaOE'] <- '*esg>da:da*'
targetsB2$Condition[targetsB2$Condition=='ScOE'] <- '*esg>scute*'
targetsB2$Condition[targetsB2$Condition=='Control'] <- '*esg>*'

ggplot(scores,
       aes(x = PC1, y = PC2, label=factor(targetsB2$sampleID), colour=factor(targetsB2$Condition))
       ) +
  geom_point(size=3) + 
  geom_text(size=3, hjust=0.5, vjust=-1) +
  scale_colour_discrete(name="condition") +
  theme(legend.text=element_markdown(size=9))
```

## 1.2 PCA of all conditions

Include the whole dataset (as opposed to only the genes with significant DE).
```{r}
targets <- rbind(targetsB1, targetsB2)
common_genes <- intersect(rownames(tpmNormalisedCountsB1), rownames(tpmNormalisedCountsB2))
tpmNormalisedCounts <- cbind(tpmNormalisedCountsB1[common_genes,],
                             tpmNormalisedCountsB2[common_genes,])
# remove all rows that have no variance
tpmNormalisedCounts_pca <- tpmNormalisedCounts[
  rowSums(tpmNormalisedCounts[-1] != tpmNormalisedCounts[[2]], na.rm = TRUE) != 0,
  ]
# pca object
pca <- prcomp(t(tpmNormalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleID, pca$x[,1:2])
# plot
ggplot(scores,
       aes(x = PC1, y = PC2, label=factor(targets$sampleID), colour=factor(targets$Condition))
       ) +
  geom_point(size=3) + 
  geom_text(size=3, hjust=0.5, vjust=-1) +
  scale_colour_discrete(name="condition") +
  theme(legend.text=element_markdown(size=9))
```
###
### this needs to be addressed with some batch correction.
###

# 2 Heatmap

Get the TMP values from the previous script
```{r}
# Load tmp values
l <- list.files(getwd())
tmpdata <- l[unlist(lapply(l, grepl, pattern='_vs_'))]
sortedFinalData_named_KD   <- readRDS( tmpdata[unlist(lapply(tmpdata, grepl, pattern='KD'))] )
sortedFinalData_named_DaDa <- readRDS( tmpdata[unlist(lapply(tmpdata, grepl, pattern='DaDa'))] )
sortedFinalData_named_OE   <- readRDS( tmpdata[unlist(lapply(tmpdata, grepl, pattern='_DaOE'))] )
sortedFinalData_named_Sc   <- readRDS( tmpdata[unlist(lapply(tmpdata, grepl, pattern='Sc'))] )
```
Plot the tpm values

```{r}
relative_Significant_Genes <- sortedFinalData_named_KD %>% 
  filter(padj <= 0.01) %>%
  filter(log2FoldChange >= 1 | log2FoldChange <= -1) %>%
  dplyr::select(external_gene_name, starts_with("TPM")) %>%
  column_to_rownames(var="external_gene_name") %>%
  data.matrix()

#heatmap(heatmap_prep)


vsd <- assay(vst(dds))
Z <- t(scale(t(vsd)))

```

