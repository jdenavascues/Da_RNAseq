### RNAseq script

We have 5 different conditions expressed with the esg-Gal4, myo1a-Gal4 drivers to cover 92% of the gut cells. The five conditions are the following: WT, emc-RNAi, UAS-da, UAS-da:da and UAS-sc.

Load DESeq2. Contains functions we will use to normalise RNAseq count data and performs the differential gene expression analysis.

```{r}
library(DESeq2)
library(edgeR)
```

Load the biomaRT package allowing us to annotate the final gene list, with common gene names.
Load the rtracklayer and GenomicFeatures packages. These contain functions for handling gene/exon coordinates data.

```{r}
library(biomaRt)
library(rtracklayer)
library(GenomicFeatures)
```

Load the ggplots libraries. These are required for making QC plots.
Load the dplyr libraries used for data manipulations such as data.frame merges and filtering.
Load the stringr libraries used for string (sentence) manipulations.

```{r include=FALSE}
library(ggplot2)
library(dplyr)
library(stringr)
```


TPM function

```{r}
tpm <- function(counts, lengths) {
  return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}

```


Set working directory into your desired folder. Not working at the moment

```{r setup}
knitr::opts_chunk$set(include = FALSE)
knitr::opts_knit$set(root.dir ='/Users/aleix/Documents/bioinformatics/RNAseq')
getwd()
```

Read the gene coordinates from the GTF file into an R data structure from resources.
Export the transcript lengths for all of the transcripts, from this object.
Use the unique() function to get a vector of all gene IDs.
Get the maximum transcript length for each gene. Maximum gene lengths are required for a gene‐length‐normalisation later in the script.

```{r include=FALSE}
txdb <- makeTxDbFromGRanges(import("/Users/aleix/Documents/bioinformatics/RNAseq/resources/dmel-all-r6.21.gtf"))

allTranscripts <- transcriptLengths(txdb)

allGeneIDs <- unique(allTranscripts$gene_id)

allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
```


```{r}
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",dataset="dmelanogaster_gene_ensembl", host = "jan2019.archive.ensembl.org")
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed

dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
```


# read in sample descriptions
We are now ready to read‐in the sample descriptions for the gene expression analysis. 
We need to define our conditions in the context of the biological replicates we have.
The raw data is not ordered by grouping the different condtions, but by the name of the experiment. Therefore when I upload the sample descriptions I have to order them.
Read this file into a data.frame.

```{r}
targets <- read.table("resources/targets.txt", header=TRUE, sep="\t")
```


# read in featureCounts for all samples

```{r}
rawData <- NULL

for (sampleID in targets$sampleID) {
    
    fileContents <- read.table(paste("/Users/aleix/Documents/bioinformatics/RNAseq/input/featurecounts/", sampleID, ".markdup.featurecount", sep=""), sep="\t", header=T)
    
    rawData <- cbind(rawData, fileContents[,7])
    
}


```

Add column and row names to the rawData data.frame.
```{r}
colnames(rawData) <- targets$sampleID
rownames(rawData) <- fileContents$Geneid


```

# Filtering for cpm < 1
We want to remove genes with low counts

```{r}
compare <- "2D"
rawData <- rawData[,c(1,2,3,13,14,15)]
new_targets <- targets[c(1,2,3,13,14,15),]

cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3
rawData <- rawData[keep,]
```


# Create a DeSEQ2 design matrix
To run DESeq2, (following the DeSEq2 analysis guide in bioconductor), we need to create an experimental design object (sample ID to treatment mapping).

```{r}
exptDesign = data.frame(

row.names = colnames(rawData),
condition = new_targets$Condition

)
```


# create a DeSEQ2 experimental object
Build a DESeq2 object containing this experimental design and rawData.

```{r}
exptObject <- DESeqDataSetFromMatrix(

countData = rawData,
colData = exptDesign,
design = ~ condition

)
```

# Hierarchical heatmap by condition
When performing quality assessment of our count data, we need to transform the normalized counts for better visualization of the variance for unsupervised clustering analyses. To assess the similarity of the samples using hierarchical heatmaps, transform the normalized counts and perform hierarchical clustering analysis.

```{r}
library(pheatmap)

# Transform the normalized counts 
vsd_Object <- vst(exptObject, blind=TRUE)

# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)

# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object) 

# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = select(exptDesign, condition))
```

Run the differential analysis. This will normalised data, correct for dispersion (variance between replicates) and set data up for a differential comparison of any 2 conditions.

```{r}
analysisObject = DESeq(exptObject)
```
After fitting the model in the previous exercise, let's explore the fit of our data to the negative binomial model by plotting the dispersion estimates using the plotDispEsts() function. Remember that the dispersion estimates are used to model the raw counts; if the dispersions don't follow the assumptions made by DESeq2, then the variation in the data could be poorly estimated and the DE results could be less accurate.

The assumptions DESeq2 makes are that the dispersions should generally decrease with increasing mean and that they should more or less follow the fitted line.

```{r}
plotDispEsts(analysisObject)
```



Retrospectively pull out the raw and normalised data from the analysis object.

```{r}
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
```



# TPM values
Then generate TPM values, using tpm() function.
```{r}
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]

tpmData <- NULL

for (colName in colnames(rawCountData)) {
    tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}

tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]

if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
    stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
    stop()
}


```

# Deciding samples to compare

```{r}
conditionOne <- compare
conditionTwo <- "WT"
```

Select the relevant column from the counts object made previously.
Add the term “raw”, “norm” or “tpm” to each of the column headings to distinguish the column names.

```{r}
slimRawCounts <- dplyr::select(rawCounts, matches( paste(conditionOne,conditionTwo, sep = "|")  ) )
slimNormalisedCounts <- dplyr::select(normalisedCounts, matches( paste(conditionOne,conditionTwo, sep = "|")  ) )
slimTpmNormalisedCounts <- dplyr::select(tpmNormalisedCounts, matches( paste(conditionOne,conditionTwo, sep = "|")  ) )

colnames(slimRawCounts) <- paste("raw", colnames(slimRawCounts), sep=".")
colnames(slimNormalisedCounts) <- paste("norm", colnames(slimNormalisedCounts), sep=".")
colnames(slimTpmNormalisedCounts) <- paste("tpm", colnames(slimTpmNormalisedCounts), sep=".")
```

Create the comparison between the 2 conditions.
Create a data.frame containing all the count and DEdata, and sorted by the pvalue column, with the most significant genes at the top of the data.frame.

```{r}
deData <- as.data.frame(results(analysisObject, contrast=c("condition", conditionOne, conditionTwo), pAdjustMethod="BH"))

finalData <- cbind(rownames(deData), slimRawCounts, slimNormalisedCounts, slimTpmNormalisedCounts, deData)

colnames(finalData)[1] <- "ensemblGeneID"
```




Sort data and give genes their names

```{r}
sortedFinalData <- finalData[order(finalData$pvalue), ] 


sortedFinalData_named <- merge(sortedFinalData, dlist, by=0)
sortedFinalData_named <- sortedFinalData_named[,-1]
```

Write this data to a file under output/

```{r}
setwd('/Users/aleix/Documents/bioinformatics/RNAseq')
write.table(sortedFinalData, file=paste("output/differential_expression/", conditionOne, "_vs_", conditionTwo, ".txt", sep=""), row.names=F, sep="\t", quote=F)

```


Get significant genes, because we want to cluster on this behaviour

```{r}
significantGenes <- as.vector(unlist(subset(sortedFinalData_named, pvalue <= 0.05, select=c("ensemblGeneID"))))

sigTpmNormalisedCounts <- subset(tpmNormalisedCounts, rownames(tpmNormalisedCounts) %in% significantGenes)
```


