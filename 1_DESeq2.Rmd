---
title: "RNAseq analysis of FAC-sorted ISC/EBs with LOF/GOF treatment for Sc/Da"
description: "DEG analysis based on DESeq2 and GSEA"
principal investigator: "Joaquín de Navascués"
researcher: "Aleix Puig, modified by Joaquín de Navascués"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: readable
    df_print: paged
    css: doc.css
---
```{r setup, echo = FALSE, cache = FALSE}
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'), 
                      fig.align = 'center', fig.height = 5, fig.width = 8.5, 
                      pdf.options(encoding = "ISOLatin9.enc"),
                      fig.path='integration/figures/', warning=FALSE, message=FALSE)
```

# 1 Getting ready

We have five different conditions expressed with the _esg-Gal4_ driver, in two batches:

* Batch `a`:
  
  * _UAS-GFP_ (?) (control)
  * _UAS-daughterless_ (_da_)
  * _UAS-da^RNAi^_ (TRiP-line, either JF02488 or JF02092)
  
* Batch `b`:

  * _UAS-GFP_ (?) (control)
  * _UAS-da:da_
  * _UAS-scute_

The target cells were labelled with UAS-GFP and FAC-sorted, RNA extracted, reverse-transcribed, amplified and sequenced with Illumina.
Importantly, the first two have their own control, while the last two have a different one, as they were made separately.
In the first version of this script, I am doing two separate analyses, but because eventually I will need to show all the data together, batch-correction will be required, which is what I will do here.

```{r, include=FALSE}
# bioinformatics
library(DESeq2)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # import function for GRanges
library(GenomicFeatures) # to handling gene/exon coordinates data
# data / plotting
library(ggplot2)
library(dplyr)
library(stringr)
library(pheatmap)        # pretty heatmaps
library(scico)           # scientific colour maps
library(dendsort)        # sort dendrograms
# convenience
#library(readr)           # to unzip (redundant with utils?)
library(writexl)
library(here)
setwd(here())
```

## Some functions used later

Calculate Transcripts Per Million counts:
```{r}
tpm <- function(counts, lengths) {
  return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
```

## Read genomic features from GTF file

Read the gene coordinates from the GTF file into an R data structure from resources.
Export the transcript lengths for all of the transcripts, from this object.
Use the unique() function to get a vector of all gene IDs.
Get the maximum transcript length for each gene. Maximum gene lengths are required for a gene‐length‐normalisation later in the script.

```{r include=FALSE, warning=FALSE}
gtf <- 'Drosophila_melanogaster.BDGP6.28.101.gtf' # same release as the one used for mapping
txdb <- makeTxDbFromGRanges( import( unzip(paste0('resources/', gtf, '.zip'), gtf) ) )
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
  group_by(gene_id) %>%
  summarize(max.tx_len = max(tx_len)) )
```

## Get the gene symbols

Genes are now identified as FlyBase IDs (e.g. FBgn0031208). To get the gene names:
```{r}
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
                     dataset="dmelanogaster_gene_ensembl",
                     host = "https://oct2022.archive.ensembl.org")
                     # to update this: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed

dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
names(dlist) <- 'gene_symbol'
write.table(dlist, file="resources/gene_symbols.txt", col.names=NA)
```

## Load raw data

Read in featureCounts for all samples:
```{r}
targets <- read.table("input/targets.txt", header=TRUE, sep="\t")

rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
  if (file.exists( paste("input/dadasc/featurecounts/",
                         sampleID,
                         ".featurecount", sep="") )){
    fileContents <- read.table(paste("input/dadasc/featurecounts/",
                                       sampleID, ".featurecount", sep=""),
                                 sep="\t",
                                 header=T)
    } else {
      fileContents <- read.table(paste("input/daoekd/featurecounts/",
                                       sampleID, ".featurecount", sep=""),
                                 sep="\t",
                                 header=T)
      }
  rawData <- cbind(rawData, fileContents[,7])
}
```

Add column and row names to the rawData matrix
```{r}
colnames(rawData) <- paste(targets$Condition, targets$Replicate, targets$Batch, sep='_')
rownames(rawData) <- fileContents$Geneid
```

We want to remove genes with low counts _in these samples_, so we do:
```{r}
cpms <- edgeR::cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples
rawData <- rawData[keep,]
```

# 2 Pipeline

## `DESeq2`-DGE analysis

Create an experimental design object that contains the information from `targets`:
```{r}
exptDesign = data.frame(
  row.names = colnames(rawData),
  condition = targets$Condition,
  batch = targets$Batch)
```

Create `DESeq2DataSet` object containing this experimental design and rawData:
```{r, warning=FALSE}
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
                                     colData = exptDesign,
                                     design = ~ batch + condition) 

exptObject$condition <- factor(exptObject$condition,
                               levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
```
`condition` needs to be last in the formula (see [here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#differential-expression-analysis) why).

### Exploratory analysis

#### Principal component analysis and batch-correction

Transform the normalized counts and plot them as PCA:
```{r}
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
```

Remove batch effect and re-plot:
```{r}
assay(vsd_Object) <- limma::removeBatchEffect( assay(vsd_Object),
                                               batch=vsd_Object$batch,
                                               design=model.matrix(~condition, colData(vsd_Object)) )
plotPCA(vsd_Object)
```

This makes sense: PC1 mostly separates *scute* overexpression from the rest, and PC2 dominates the effect of knocking-down or overexpressing *daughterless* (or the *da:da* variant).

#### Sample correlations

When performing quality assessment of our count data, we need to transform the normalized counts for better visualization of the variance for unsupervised clustering analyses. To assess the similarity of the samples using hierarchical heatmaps, transform the normalized counts and perform hierarchical clustering analysis (with hidden dendrograms)
```{r, fig.height=6}
# this bit of code is a bit longer than it needs to
# as I was experimenting to get the heatmap closer to publication standard

# Compute the correlation values between samples
vsd_cor_Object <- cor(assay(vsd_Object)) 

# heatmap
main.title <- 'RNAseq sample correlations'
## get sorted clusters
sort_hclust <- function(x) as.hclust(dendsort(as.dendrogram(x)))
mat_cluster_cols <- hclust(dist(t(vsd_cor_Object)))
mat_cluster_cols <- sort_hclust(mat_cluster_cols)
mat_cluster_rows <- hclust(dist(vsd_cor_Object))
mat_cluster_rows <- sort_hclust(mat_cluster_rows)
## mark the batches
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
                                         yes = 'batch A',
                                         no = 'batch B'))
rownames(annot_batch) <- rownames(vsd_cor_Object)
## get minimum correlation value, rounded for the legend
bot <- ceiling(min(vsd_cor_Object)*100)/100
## plot
pheatmap(
  # data
    mat               = vsd_cor_Object,
    scale             = "none", # otherwise numbers are changed
    cellwidth         = 15,
    cellheight        = 15,
  # title
    main              = main.title,
    fontsize          = 14,
    annotation        = dplyr::select(exptDesign, condition),
  # rows
    cluster_rows      = mat_cluster_rows,
    treeheight_row    = 25, # default is 50
    show_rownames     = TRUE,
    labels_row        = rownames(exptDesign),
    fontsize_row      = 9,
    annotation_row    = annot_batch,
  # cols
    cluster_cols      = mat_cluster_cols,
    treeheight_col    = 25,
    show_colnames     = TRUE,
    labels_col        = rownames(exptDesign),
    fontsize_col      = 9,
    angle_col         = 45,
  # legends
    legend_breaks     = c(bot, 1),
  # tiles
    color             = scico(255, palette='bamako'),
    border_color      = 'grey80')
```

### Differential expression analysis

This will normalise the data, correct for dispersion (variance between replicates) and set data up for a differential comparison of any 2 conditions.
```{r}
analysisObject = DESeq(exptObject)
```

#### Dispersion estimates

After fitting the model with the previous command, let us explore the fit of our data to the negative binomial model by plotting the dispersion estimates using the `plotDispEsts()` function. Remember that the dispersion estimates are used to model the raw counts; if the dispersions do not follow the assumptions made by DESeq2, then the variation in the data could be poorly estimated and the DE results could be less accurate.

The assumptions DESeq2 makes are that the dispersions should generally decrease with increasing mean and that they should more or less follow the fitted line.
```{r}
plotDispEsts(analysisObject)
```

This seems reasonably in order, so we move on. Now we just need from `DESeq2` the "`p-values`" and the "`log2 fold changes`" using `results`.
We will first obtain the "`tmp`" values for the gene-based plots, and include them alongside the raw and DESeq2-normalised counts, and the DGE data, in the supplementary data - that should be enough for anyone to do their own light analysis without having to get the reads from GEO.

#### Save counts for visualisation

This looks reasonable, so let us move on by extracting the rawCounts and the normalisedCounts:
```{r}
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
```

Also obtain the TPMs as a normalisation value:
```{r}
# add column with transcript lengths, turn GeneID rownames into column
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]

# create matrix of TPM values per sample
tpmData <- NULL
for (colName in colnames(rawCountData)) {
    tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
# turn TPM into dataframe
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
# reduce TPM to the genes detected in the RNAseq samples
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]

# test that the rows are still the same:
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
    stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
    stop()
}
# test that there is information for all of them (e.g. no mismatch between the GTF files used)
cat(
  cat('There are\t',nrow(rawCounts),
      '\tgenes listed in `rawCounts`, and there are data for\t\t',
      nrow(na.omit(rawCounts)), '\tof them.\n'),
  cat('There are\t',nrow(normalisedCounts),
      '\tgenes listed in `normalisedCounts`, and there are data for\t',
      nrow(na.omit(normalisedCounts)), '\tof them.\n'),
  cat('There are\t',nrow(tpmNormalisedCounts),
      '\tgenes listed in `tpmNormalisedCounts`, and there are data for\t',
      nrow(na.omit(tpmNormalisedCounts)), '\tof them.\n')
)
```

All seems fine, so we can store these data. For visualisation:
```{r}
# for downstream use
saveRDS(rawCounts, 'output/rawCounts.RDS')
saveRDS(normalisedCounts, 'output/normalisedCounts.RDS')
saveRDS(tpmNormalisedCounts, 'output/tpmNormalisedCounts.RDS')
```

#### Save DGE data

Loop over the experimental conditions and save `DESeq2::results` as RDS and in Supplementary Table S3:
```{r, warning=FALSE}
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names 

for (condtn in test_conditions) {
  # get the Counts for those conditions
  deData <- as.data.frame(results(analysisObject,
                                  contrast=c("condition", 'Control', condtn),
                                  pAdjustMethod="BH"))
  # add column of ID
  deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
  # sort by pval
  deData <- deData[order(deData$pvalue), ] 
  # add gene symbol column and reorder columns
  deData <- merge(deData, dlist, by=0)
  deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
  # save for later
  saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
  # save as Supplementary data for publication
  tests[[paste0('Control_vs_', condtn)]] <- deData
}
```

#### Produce Supplementary material

Supplementary Table S3:
```{r}
# add `rawCounts` to `tests`
tests <- rlist::list.append(tests, `Raw counts per gene per sample`=rawCounts)
# Supplementary data for publication
write_xlsx(tests, path='output/Table S3.xlsx')
```

Finally, to have the experimental designed captured in a flexible manner:
```{r}
targets$condition_md <- plyr::mapvalues(
  targets$Condition,
  from=unique(targets$Condition),
  to=c('*da^RNAi^*', '*da^OVEX^*', '*wild-type*', '*da:da^OVEX^*', '*scute^OVEX^*')
  )
targets$condition_md <- factor(
  targets$condition_md,
  c('*wild-type*', '*da^OVEX^*', '*da:da^OVEX^*','*da^RNAi^*', '*scute^OVEX^*')
  )
saveRDS(targets, 'output/targets.RDS')
```

We now move on to preparing descriptive figures. After, to gene set analysis.
