---
title: "RNAseq analysis of FAC-sorted ISC/EBs with LOF/GOF treatment for Sc/Da"
description: "Tests for production plotting"
principal investigator: "Joaquín de Navascués"
researcher: "Joaquín de Navascués"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    theme: readable
    df_print: paged
---
```{r set-publication-theme, echo=FALSE, cache=FALSE}
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
```

```{r setup, echo = FALSE, cache = FALSE}
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'), 
                      fig.align = 'center', fig.height = 5, fig.width = 8.5, 
                      pdf.options(encoding = "ISOLatin9.enc"),
                      fig.path='integration/figures/', warning=FALSE, message=FALSE)
```

# 1 Getting ready

We have five different conditions expressed with the _esg-Gal4_ driver, in two batches:

* Batch `a`:
  
  * _UAS-GFP_ (?) (control)
  * _UAS-daughterless_ (_da_)
  * _UAS-da^RNAi^_ (TRiP-line, either JF02488 or JF02092)
  
* Batch `b`:

  * _UAS-GFP_ (?) (control)
  * _UAS-da:da_
  * _UAS-scute_

The target cells were labelled with UAS-GFP and FAC-sorted, RNA extracted, reverse-transcribed, amplified and sequenced with Illumina.
Importantly, the first two have their own control, while the last two have a different one, as they were made separately.
In the first version of this script, I am doing two separate analyses, but because eventually I will need to show all the data together, batch-correction will be required, which is what I will do here.

```{r, include=FALSE}
# DGE analysis
library(DESeq2)          # to normalise RNAseq count data and perform DEG analysis
# general bioinformatics
library(edgeR)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # to handling gene/exon coordinates data
library(GenomicFeatures) # to handling gene/exon coordinates data
# batch correction
#library(sva) # >= v3.36.0
#library(BatchQC)
#library(preprocessCore)
# library(limma)
# plotting and data tidying
library(ggplot2)         # for making plots
library(dplyr)           # for handling data frames
library(stringr)         # for handling strings
library(pheatmap)        # to plot heatmap
library(scico)           # for vik colour map
library(dendsort)        # to sort dendrograms
library(gridExtra)
library(UpSetR)
library(ggthemes)        # italics in the figures
library(ggtext)          # italics in the figures
library(gridExtra)
#library(ggplotify)
# general convenience
library(here)
setwd(here())
```

#### Some functions used later

Calculate Transcripts Per Million counts:
```{r}
tpm <- function(counts, lengths) {
  return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
```

#### Read genomic features from GTF file

Read the gene coordinates from the GTF file into an R data structure from resources.
Export the transcript lengths for all of the transcripts, from this object.
Use the unique() function to get a vector of all gene IDs.
Get the maximum transcript length for each gene. Maximum gene lengths are required for a gene‐length‐normalisation later in the script.

```{r, echo=FALSE, warning=FALSE}
gtf <- 'Drosophila_melanogaster.BDGP6.28.101.gtf' # same release as the one used for mapping
zipfile <- paste0('resources/', gtf, '.zip')
txdb <- makeTxDbFromGRanges( import( unzip(zipfile, gtf) ) )
unlink(gtf) # cleanup - delete uncompressed file
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
  group_by(gene_id) %>%
  summarize(max.tx_len = max(tx_len)) )
```

#### Get the gene symbols

Genes are now identified as FlyBase IDs (e.g. FBgn0031208). To get the gene names:

```{r}
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
                     dataset="dmelanogaster_gene_ensembl",
                     host = "https://oct2022.archive.ensembl.org")
                     # to update this: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed

dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
names(dlist) <- 'gene_symbol'
```

#### Load raw data

Read in featureCounts for all samples:
```{r}
targets <- read.table("input/targets.txt", header=TRUE, sep="\t")
zipfiles <- unzip("input/featurecounts.zip",list=TRUE)
fcountf <- zipfiles$Name[ grepl('.featurecount$', zipfiles$Name) &
                          !(grepl('^_', zipfiles$Name) )]

rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
counter <- 0
for (fcf in targets$File) {
  if (fcf %in% fcountf) {
    fileContents <- read.table(unzip("input/featurecounts.zip", file=fcf), sep="\t", header=T)

    } else { counter <- counter + 1 }
  rawData <- cbind(rawData, fileContents[,7])
}
if (counter>0) {cat("There is/are ", counter, ' missing featureCount file(s) in the zipped directory')}
unlink('*.featurecount') # cleanup - delete uncompressed files
```

Add column and row names to the rawData matrix
```{r}
colnames(rawData) <- paste(targets$Condition, targets$Replicate, targets$Batch, sep='_')
rownames(rawData) <- fileContents$Geneid
```

We want to remove genes with low counts _in these samples_, so we do:
```{r}
cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples (out of 6, originally)
rawData <- rawData[keep,]
```

# Pipeline: `DESeq2`-DGE analysis, visualisation with `limma`-based batch correction

## `DESeq2`-DGE analysis

Create an experimental design object that contains the information from `targets`:
```{r}
exptDesign = data.frame(
  row.names = colnames(rawData),
  condition = targets$Condition,
  batch = targets$Batch)
```

Create `DESeq2DataSet` object containing this experimental design and rawData:
```{r, warning=FALSE}
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
                                     colData = exptDesign,
                                     design = ~ batch + condition) 

exptObject$condition <- factor(exptObject$condition, levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
```
`condition` needs to be last in the formula (see [here](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#differential-expression-analysis) why).

#### Quick visualisation

Transform the normalized counts and plot them as PCA:
```{r}
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
```

Remove batch effect and re-plot:
```{r}
assay(vsd_Object) <- limma::removeBatchEffect( assay(vsd_Object),
                                               batch=vsd_Object$batch,
                                               design=model.matrix(~condition, colData(vsd_Object)) )
plotPCA(vsd_Object)
```

This makes sense: PC1 mostly separates *scute* overexpression from the rest, and PC2 dominates the effect of knocking-down or overexpressing *daughterless* (or the *da:da* variant).

#### Basic QC

When performing quality assessment of our count data, we need to transform the normalized counts for better visualization of the variance for unsupervised clustering analyses. To assess the similarity of the samples using hierarchical heatmaps, transform the normalized counts and perform hierarchical clustering analysis (with hidden dendrograms)
(I spend some time customising the plot for later, when I plot the z-scores)
```{r}
# Compute the correlation values between samples of the matrix of transformed (and batch-corrected) counts
vsd_cor_Object <- cor(assay(vsd_Object)) 

# heatmap
main.title <- '*RNAseq* sample correlations'
## get sorted clusters
sort_hclust <- function(x) as.hclust(dendsort(as.dendrogram(x)))
mat_cluster_cols <- hclust(dist(t(vsd_cor_Object)))
mat_cluster_cols <- sort_hclust(mat_cluster_cols)
mat_cluster_rows <- hclust(dist(vsd_cor_Object))
mat_cluster_rows <- sort_hclust(mat_cluster_rows)
## mark the batches
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
                                         yes = 'batch A',
                                         no = 'batch B'))
rownames(annot_batch) <- rownames(vsd_cor_Object)
## annotation labels
ann_labels <- dplyr::select(exptDesign, condition)
ann_labels$condition <- plyr::mapvalues(exptDesign$condition,
                                       from=unique(exptDesign$condition),
                                       to=c('da RNAi', 'da o/e', 'control', 'da:da o/e', 'scute o/e'))
ann_labels$condition <- factor(ann_labels$condition, levels=c('control', 'da o/e', 'da:da o/e', 'da RNAi', 'scute o/e'))
## annotation colours
ann_colors = list(
  batch = c('batch A' = RColorBrewer::brewer.pal(12, 'Paired')[2],
            'batch B' = RColorBrewer::brewer.pal(12, 'Paired')[8]),
  condition = c("da RNAi" = RColorBrewer::brewer.pal(12, 'Paired')[9],
                "da o/e" = RColorBrewer::brewer.pal(12, 'Paired')[5],
                "control" = RColorBrewer::brewer.pal(12, 'Paired')[1],
                "da:da o/e" = RColorBrewer::brewer.pal(12, 'Paired')[6],
                "scute o/e" = RColorBrewer::brewer.pal(12, 'Paired')[4])
  )
## mark the samples for ggtext
labels_sample <- data.frame(sample=c(paste(rep('da-RNAi', 3),1:3),
                                     paste(rep('da', 2),     1:2),
                                     paste(rep('control', 6),rep(1:3,2)),
                                     paste(rep('da:da', 3),  1:3),
                                     paste(rep('scute', 3),  1:3)))
rownames(labels_sample) <- rownames(vsd_cor_Object)
## get minimum correlation value, rounded for the legend
bot <- ceiling(min(vsd_cor_Object)*100)/100
```

```{r, fig.height=6}
hm <- pheatmap(
  # data
    mat               = vsd_cor_Object[mat_cluster_rows$order, mat_cluster_cols$order], # manually ordered as in clusters
    scale             = "none", # otherwise numbers are changed
    cellwidth         = 15,
    cellheight        = 15,
  # title
    main              = main.title,
    fontsize          = 14,
  # rows
    cluster_rows      = FALSE,#mat_cluster_rows,
    #treeheight_row    = 25, # default is 50
    #cutree_rows       = 4,
    gaps_row          = c(6,9,12,14),
    show_rownames     = TRUE,
    labels_row        = labels_sample$sample[mat_cluster_rows$order],
    fontsize_row      = 9,
    annotation_row    = annot_batch,
  # cols
    cluster_cols      = FALSE,#mat_cluster_cols,
    #treeheight_col    = 25,
    #cutree_cols       = 4,
    show_colnames     = TRUE,
    labels_col        = labels_sample$sample[mat_cluster_cols$order],
    fontsize_col      = 9,
    angle_col         = 45,
  # legends
    annotation        = ann_labels,
    annotation_colors = ann_colors,
    legend_breaks     = c(bot, bot+(1-bot)/2, 1),
  # tiles
    color             = scico(255, palette='bamako'),
    border_color      = NA,
    #display_numbers   = TRUE,
    #fontsize_number   = 5,
    #number_color      = 'white',
  # save plot
    #filename          = 'RNAseq_sample_corr.png',
    #width             = 8,
    #height            = 6
  )
hm
```
Note that for a 'publication' customised plot, it will probably be better to go the `ggplot2` route using [this approach](https://jcoliver.github.io/learn-r/008-ggplot-dendrograms-and-heatmaps.html) or [this one](https://stackoverflow.com/questions/36852101/r-legend-title-or-units-when-using-pheatmap).

Some tips for further modifying the `pheatmap` output are [here](https://stackoverflow.com/questions/33292067/pheatmap-annotation-colors-and-border).

#### Run the DGE analysis and plot dispersion estimates

This will normalise the data, correct for dispersion (variance between replicates) and set data up for a differential comparison of any 2 conditions.
```{r}
analysisObject = DESeq(exptObject)
```

After fitting the model with the previous command, let us explore the fit of our data to the negative binomial model by plotting the dispersion estimates using the `plotDispEsts()` function. Remember that the dispersion estimates are used to model the raw counts; if the dispersions do not follow the assumptions made by DESeq2, then the variation in the data could be poorly estimated and the DE results could be less accurate.

The assumptions DESeq2 makes are that the dispersions should generally decrease with increasing mean and that they should more or less follow the fitted line.
```{r}
plotDispEsts(analysisObject)
```

# FROM HERE WE CAN JUST GET THE LOG2FC FOR GSEA, AND THEN NORMALISED COUNTS/TMPS TO DO THE GENE-BASED VISUALISATIONS
# but we do not need them for the DGE analysis, they will just be propagated for other scripts...





























This looks reasonable, so let us move on by extracting the rawCounts and the normalisedCounts:
```{r}
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
```

#### Transcript Per Million counts values

There are some arguments in favour of using TPM as a normalisation value, as it 'feels' a more natural measure of gene expression...
```{r}
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]

tpmData <- NULL

for (colName in colnames(rawCountData)) {
    tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}

tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]

if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
    stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
    stop()
}
saveRDS(tpmNormalisedCounts, 'batched_counts.RDS')
```

### 2.1.1 _da_ knock-down vs control

```{r}
conditionOne <- 'Control'
conditionTwo <- 'DaKD'
```

Select the relevant column from the counts object made previously.
Add the term “raw”, “norm” or “tpm” to each of the column headings to distinguish the column names.
```{r}
conditions_sampleIDs <- targets[targets$Condition %in% c(conditionOne, conditionTwo),]$sampleIDs
slimRawCounts           <- rawCounts           %>% select(all_of(conditions_sampleIDs))
slimNormalisedCounts    <- normalisedCounts    %>% select(all_of(conditions_sampleIDs))
slimTpmNormalisedCounts <- tpmNormalisedCounts %>% select(all_of(conditions_sampleIDs))

colnames(slimRawCounts)           <- paste("raw", conditions_sampleIDs, sep=".")
colnames(slimNormalisedCounts)    <- paste("norm", conditions_sampleIDs, sep=".")
colnames(slimTpmNormalisedCounts) <- paste("tpm", conditions_sampleIDs, sep=".")
```

Create the comparison between the 2 conditions.
Create a data.frame containing all the count and DEdata, and sorted by the pvalue column, with the most significant genes at the top of the data.frame.
```{r}
deData <- as.data.frame(results(analysisObject, contrast=c("condition", conditionOne, conditionTwo), pAdjustMethod="BH"))
finalData <- cbind(rownames(deData), slimRawCounts, slimNormalisedCounts, slimTpmNormalisedCounts, deData)
colnames(finalData)[1] <- "ensemblGeneID"
```

Sort data and give genes their names
```{r}
sortedFinalData <- finalData[order(finalData$pvalue), ] 
sortedFinalData_named <- merge(sortedFinalData, dlist, by=0)
sortedFinalData_named <- sortedFinalData_named[,-1]
```

Write this data to a file under output/
```{r}
write.table(sortedFinalData, file=paste("output/batched/differential_expression/", conditionOne, "_vs_", conditionTwo, ".txt", sep=""), row.names=F, sep="\t", quote=F)
saveRDS(sortedFinalData_named, paste(conditionOne, "_vs_", conditionTwo, ".RDS", sep="") )
```

Get significant genes, because we want to cluster on this behaviour
```{r}
significantGenes <- as.vector(unlist(subset(sortedFinalData_named, pvalue <= 0.05, select=c("ensemblGeneID"))))
sigTpmNormalisedCounts <- subset(tpmNormalisedCounts, rownames(tpmNormalisedCounts) %in% significantGenes)
```
