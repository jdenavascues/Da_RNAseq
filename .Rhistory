#                        cet_pal(n = 5, name = "cbd1", alpha = 1)[[4]]),
#                      2),
set_size.show = TRUE,
set_size.numbers_size = 6,
set_size.scale_max = (ceiling(max(sapply( up , length)) / 100)*100)+50, # analog to plyr::round_any
# intersections
main.bar.color = 'gray50',
# c(rep("black", 6), rep('gray50', 8), rep("black", 6), rep('gray50', 7)),
group.by = 'sets',
order.by = "degree",
# labels
number.angles = 0,
mainbar.y.label = "Condition Intersections",
sets.x.label = "DEGs per condition",
text.scale = c(1.5, 1.3,  # c(ylab, yticks,
1.5, 1.3,  #   xlab, xticks,
1.3, 1.3), #   setlabs, barnumbers)
# connections
matrix.color = 'gray50',
shade.color = cet_pal(n = 5, name = "cbd1", alpha = 1)[[4]],
point.size = 3,
line.size = 0.75
)
pdf(file=paste0(figdir,'/UpSet_plot_up_logfc2.pdf'),
width=8, height=4.5)
upsetplot
grid.text("Set intersections for DEGs fc>4", x = 0.65, y=0.95, gp=gpar(fontsize=18)) #≥
dev.off()
svg(file=paste0(figdir,'/UpSet_plot_up_logfc2.svg'),
width=8, height=4.5)
upsetplot
grid.text("Set intersections for DEGs fc>4", x = 0.65, y=0.95, gp=gpar(fontsize=18))
dev.off()
tiff(file=paste0(figdir,'/UpSet_plot_up_logfc2.tiff'),
width=8, height=4.5, units="in", res=300)
upsetplot
grid.text("Set intersections for DEGs fc>4", x = 0.65, y=0.95, gp=gpar(fontsize=18))
dev.off()
png(file=paste0(figdir,'/UpSet_plot_up_logfc2.png'),
width=8, height=4.5, units="in", res=300)
upsetplot
grid.text("Set intersections for DEGs fc>4", x = 0.65, y=0.95, gp=gpar(fontsize=18))
dev.off()
upsetplot
grid.text("Set intersections for DEGs fc≥4", x = 0.65, y=0.95, gp=gpar(fontsize=18))
downsetplot <- upset(
# data
fromList(  down  ),
mb.ratio = c(0.7, 0.3), # intersection bars, set bars
queries = list(
list(query = intersects,
params = list('da RNAi'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('da'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('da:da'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('scute'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T)
),
# sets
sets = names(up), keep.order= TRUE,
sets.bar.color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
set_size.show = TRUE,
set_size.numbers_size = 6,
set_size.scale_max = ceiling(max(sapply( down , length)) / 100)*100,
# intersections
main.bar.color = 'gray50',
group.by = 'sets',
order.by = "degree",
# labels
number.angles = 0,
mainbar.y.label = "Condition Intersections",
sets.x.label = "DEGs per condition",
text.scale = c(1.5, 1.3,  # c(ylab, yticks,
1.5, 1.3,  #   xlab, xticks,
1.3, 1.3), #   setlabs, barnumbers)
# connections
matrix.color = 'gray50',
shade.color = cet_pal(n = 5, name = "cbd1", alpha = 1)[[2]],
point.size = 3,
line.size = 0.75
)
pdf(file=paste0(figdir,'/UpSet_plot_down_logfc2.pdf'),
width=8, height=4.5)
upsetplot
grid.text("Fold change ≤ ¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
svg(file=paste0(figdir,'/UpSet_plot_down_logfc2.svg'),
width=8, height=4.5)
upsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
tiff(file=paste0(figdir,'/UpSet_plot_down_logfc2.tiff'),
width=10, height=12, units="in", res=300)
upsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
png(file=paste0(figdir,'/UpSet_plot_down_logfc2.png'),
width=10, height=12, units="in", res=300)
upsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
downsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
downsetplot <- upset(
# data
fromList(  down  ),
mb.ratio = c(0.7, 0.3), # intersection bars, set bars
queries = list(
list(query = intersects,
params = list('da RNAi'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('da'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('da:da'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T),
list(query = intersects,
params = list('scute'),
color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
active = T)
),
# sets
sets = names(up), keep.order= TRUE,
sets.bar.color = cet_pal(n = 2, name = "cbd1", alpha = 1)[[1]],
set_size.show = TRUE,
set_size.numbers_size = 6,
set_size.scale_max = ceiling(max(sapply( down , length)) / 100)*100,
# intersections
main.bar.color = 'gray50',
group.by = 'sets',
order.by = "degree",
# labels
number.angles = 0,
mainbar.y.label = "Condition Intersections",
sets.x.label = "DEGs per condition",
text.scale = c(1.5, 1.3,  # c(ylab, yticks,
1.5, 1.3,  #   xlab, xticks,
1.3, 1.3), #   setlabs, barnumbers)
# connections
matrix.color = 'gray50',
shade.color = cet_pal(n = 5, name = "cbd1", alpha = 1)[[2]],
point.size = 3,
line.size = 0.75
)
pdf(file=paste0(figdir,'/UpSet_plot_down_logfc2.pdf'),
width=8, height=4.5)
downsetplot
grid.text("Fold change ≤ ¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
svg(file=paste0(figdir,'/UpSet_plot_down_logfc2.svg'),
width=8, height=4.5)
downsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
tiff(file=paste0(figdir,'/UpSet_plot_down_logfc2.tiff'),
width=10, height=12, units="in", res=300)
downsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
png(file=paste0(figdir,'/UpSet_plot_down_logfc2.png'),
width=10, height=12, units="in", res=300)
downsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
dev.off()
downsetplot
grid.text("Set intersections for DEGs fc<¼", x = 0.65, y=0.95, gp=gpar(fontsize=18)) # ½
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
knitr::opts_chunk$set(dev = 'png',
fig.align = 'center', fig.height = 7, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
if (!require("librarian")) install.packages("librarian")
librarian::shelf(
# data
dplyr, stringr, DESeq2, edgeR, biomaRt, rtracklayer, GenomicFeatures, limma,
# graphics
ggplot2, pheatmap, scico, dendsort,
# convenience
here, writexl, gzcon)
setwd(here())
if (Sys.getenv("USER")=="JQ") {
setwd("/Users/JQ/Documents/_CODE REPOS/GitHub/Da_RNAseq")
} else if (Sys.getenv("RSTUDIO")==1) {
setwd( dirname(rstudioapi::getSourceEditorContext(id = NULL)$path) ) # gets what is in the editor
} else {
setwd(here::here())
d <- str_split(getwd(),'/')[[1]][length(str_split(getwd(),'/')[[1]])]
if (d != 'Da_RNAseq') { stop(
paste0("Could not set working directory automatically to where this",
" script resides.\nPlease do `setwd()` manually"))
}
}
getwd()
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
figdir <- paste0(c(head(str_split(getwd(),'/')[[1]],-1),
paste0(tail(str_split(getwd(),'/')[[1]],1), '_figures')),
collapse='/')
dir.create(figdir, showWarnings = FALSE)
gtfurl <- paste0('https://ftp.ensembl.org/pub/release-101/gtf/',
'drosophila_melanogaster/',
'Drosophila_melanogaster.BDGP6.28.101.gtf.gz')
txdb <- makeTxDbFromGRanges( import( GFFFile(gtfurl) ) )
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org")
# to update this: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
names(dlist) <- 'gene_symbol'
write.table(dlist, file="resources/gene_symbols.txt", col.names=NA)
targets <- read.table("input/targets.txt", header=TRUE, sep="\t")
zipfiles <- unzip("input/featurecounts.zip",list=TRUE)
fcountf <- zipfiles$Name[ grepl('.featurecount$', zipfiles$Name) &
!(grepl('^_', zipfiles$Name) )]
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
counter <- 0
for (fcf in targets$File) {
if (fcf %in% fcountf) {
fileContents <- read.table(unzip("input/featurecounts.zip", file=fcf), sep="\t", header=T)
} else { counter <- counter + 1 }
rawData <- cbind(rawData, fileContents[,7])
}
if (counter>0) {cat("There is/are ", counter, ' missing featureCount file(s) in the zipped directory')}
unlink('*.featurecount') # cleanup - delete uncompressed files
colnames(rawData) <- paste(targets$Condition, targets$Replicate, targets$Batch, sep='_')
rownames(rawData) <- fileContents$Geneid
cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
colData = exptDesign,
design = ~ batch + condition)
exptObject$condition <- relevel(exptObject$condition, ref = "Control") # specifies 'Control' as the reference level
vsd_Object <- vst(exptObject, blind=TRUE)
saveRDS(vsd_Object, 'output/vst_pseudocounts.RDS')
plotPCA(vsd_Object)
assay(vsd_Object) <- removeBatchEffect(
assay(vsd_Object),
batch=vsd_Object$batch,
design=model.matrix(~condition, colData(vsd_Object))
)
saveRDS(vsd_Object, 'output/vst_pseudocounts_batchCorrected.RDS')
plotPCA(vsd_Object)
# this bit of code is a bit longer than it needs to
# as I was experimenting to get the heatmap closer to publication standard
# Compute the correlation values between samples
vsd_cor_Object <- cor(assay(vsd_Object))
# heatmap
main.title <- 'RNAseq sample correlations'
## get sorted clusters
sort_hclust <- function(x) as.hclust(dendsort(as.dendrogram(x)))
mat_cluster_cols <- hclust(dist(t(vsd_cor_Object)))
mat_cluster_cols <- sort_hclust(mat_cluster_cols)
mat_cluster_rows <- hclust(dist(vsd_cor_Object))
mat_cluster_rows <- sort_hclust(mat_cluster_rows)
## mark the batches
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
yes = 'batch A',
no = 'batch B'))
rownames(annot_batch) <- rownames(vsd_cor_Object)
## get minimum correlation value, rounded for the legend
bot <- ceiling(min(vsd_cor_Object)*100)/100
## plot
pheatmap(
# data
mat               = vsd_cor_Object,
scale             = "none", # otherwise numbers are changed
cellwidth         = 15,
cellheight        = 15,
# title
main              = main.title,
fontsize          = 14,
annotation        = dplyr::select(exptDesign, condition),
# rows
cluster_rows      = mat_cluster_rows,
treeheight_row    = 25, # default is 50
show_rownames     = TRUE,
labels_row        = rownames(exptDesign),
fontsize_row      = 9,
annotation_row    = annot_batch,
# cols
cluster_cols      = mat_cluster_cols,
treeheight_col    = 25,
show_colnames     = TRUE,
labels_col        = rownames(exptDesign),
fontsize_col      = 9,
angle_col         = 45,
# legends
legend_breaks     = c(bot, 1),
# tiles
color             = scico(255, palette='bamako'),
border_color      = 'grey80')
saveRDS(vsd_Object, 'output/vsd.RDS')
analysisObject = DESeq(exptObject)
plotDispEsts(analysisObject)
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
# add column with transcript lengths, turn GeneID rownames into column
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
# create matrix of TPM values per sample
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
# turn TPM into dataframe
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
# reduce TPM to the genes detected in the RNAseq samples
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
# test that the rows are still the same:
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
# test that there is information for all of them (e.g. no mismatch between the GTF files used)
cat(
cat('There are\t',nrow(rawCounts),
'\tgenes listed in `rawCounts`, and there are data for\t\t',
nrow(na.omit(rawCounts)), '\tof them.\n'),
cat('There are\t',nrow(normalisedCounts),
'\tgenes listed in `normalisedCounts`, and there are data for\t',
nrow(na.omit(normalisedCounts)), '\tof them.\n'),
cat('There are\t',nrow(tpmNormalisedCounts),
'\tgenes listed in `tpmNormalisedCounts`, and there are data for\t',
nrow(na.omit(tpmNormalisedCounts)), '\tof them.\n')
)
# for downstream use
saveRDS(rawCounts, 'output/rawCounts.RDS')
saveRDS(normalisedCounts, 'output/normalisedCounts.RDS')
saveRDS(tpmNormalisedCounts, 'output/tpmNormalisedCounts.RDS')
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", condtn, 'Control'), # Reference goes last!
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
tests[[paste0('Control_vs_', condtn)]] <- deData
}
View(tests)
View(tests[[1]])
tableS3 <- tests
View(tableS3[[1]])
for (item in tableS3) {item['Row.names'] <- NULL}
View(tableS3[[1]])
tableS3[[1]]$Row.names <- NULL
tableS3[[2]]$Row.names <- NULL
tableS3[[3]]$Row.names <- NULL
tableS3[[4]]$Row.names <- NULL
View(tableS3[[1]])
View(tableS3[[5]])
for (item in tableS3) {item$baseMean <- NULL}
View(tableS3[[1]])
tableS3 <- lapply(tableS3, \(x) x$baseMean <- NULL)
View(tableS3[[1]])
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", condtn, 'Control'), # Reference goes last!
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
tests[[paste0('Control_vs_', condtn)]] <- deData
}
test_conditions
condtn
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", condtn, 'Control'), # Reference goes last!
pAdjustMethod="BH"))
head(deData)
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
head(deData)
deData <- deData[order(deData$pvalue), ]
deData <- merge(deData, dlist, by=0)
head(deData)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
deData
cols <- c('gene_symbol', 'ensemblGeneID', 'log2FoldChange', 'padj')
deData %>% dplyr::select(cols)
deData %>% dplyr::select(all_of(cols))
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", condtn, 'Control'), # Reference goes last!
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
cols <- c('gene_symbol', 'ensemblGeneID', 'log2FoldChange', 'padj')
tests[[paste0('Control_vs_', condtn)]] <- deData %>% dplyr::select(all_of(cols))
}
# add `rawCounts` to `tests`
tests <- rlist::list.append(tests, `Raw counts per gene per sample`=rawCounts)
# Supplementary data for publication
write_xlsx(tests, path = 'output/Table S3.xlsx', rownames = FALSE)
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", condtn, 'Control'), # Reference goes last!
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
cols <- c('gene_symbol', 'ensemblGeneID', 'log2FoldChange', 'padj')
rownames(deData) <- NULL
tests[[paste0('Control_vs_', condtn)]] <- deData %>% dplyr::select(all_of(cols))
}
# add `rawCounts` to `tests`
tests <- rlist::list.append(tests, `Raw counts per gene per sample`=rawCounts)
# Supplementary data for publication
write_xlsx(tests, path = 'output/Table S3.xlsx')
targets$condition_md <- plyr::mapvalues(
targets$Condition,
from=unique(targets$Condition),
to=c('*da^RNAi^*', '*da*', '*wild-type*', '*da:da*', '*scute*')
)
targets$condition_md <- factor(
targets$condition_md,
c('*wild-type*', '*da*', '*da:da*','*da^RNAi^*', '*scute*')
)
saveRDS(targets, 'output/targets.RDS')
