library(dplyr)
library(stringr)
library(pheatmap)        # pretty heatmaps
library(scico)           # scientific colour maps
library(dendsort)        # sort dendrograms
# convenience
library(writexl)
library(here)
setwd(here())
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
txdb <- makeTxDbFromGRanges(import('resources/Drosophila_melanogaster.BDGP6.28.101.gtf'))
# same release as the one used for mapping
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org")
# to update this: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
names(dlist) <- 'gene_symbol'
write.table(dlist, file="resources/gene_symbols.txt", col.names=NA)
targets <- read.table("input/targets.txt", header=TRUE, sep="\t")
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
if (file.exists( paste("input/dadasc/featurecounts/",
sampleID,
".featurecount", sep="") )){
fileContents <- read.table(paste("input/dadasc/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
} else {
fileContents <- read.table(paste("input/daoekd/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
}
rawData <- cbind(rawData, fileContents[,7])
}
colnames(rawData) <- paste(targets$Condition, targets$Replicate, targets$Batch, sep='_')
rownames(rawData) <- fileContents$Geneid
cpms <- edgeR::cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
colData = exptDesign,
design = ~ batch + condition)
exptObject$condition <- factor(exptObject$condition,
levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect( assay(vsd_Object),
batch=vsd_Object$batch,
design=model.matrix(~condition, colData(vsd_Object)) )
plotPCA(vsd_Object)
# this bit of code is a bit longer than it needs to
# as I was experimenting to get the heatmap closer to publication standard
# Compute the correlation values between samples
vsd_cor_Object <- cor(assay(vsd_Object))
# heatmap
main.title <- 'RNAseq sample correlations'
## get sorted clusters
sort_hclust <- function(x) as.hclust(dendsort(as.dendrogram(x)))
mat_cluster_cols <- hclust(dist(t(vsd_cor_Object)))
mat_cluster_cols <- sort_hclust(mat_cluster_cols)
mat_cluster_rows <- hclust(dist(vsd_cor_Object))
mat_cluster_rows <- sort_hclust(mat_cluster_rows)
## mark the batches
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
yes = 'batch A',
no = 'batch B'))
rownames(annot_batch) <- rownames(vsd_cor_Object)
## get minimum correlation value, rounded for the legend
bot <- ceiling(min(vsd_cor_Object)*100)/100
## plot
pheatmap(
# data
mat               = vsd_cor_Object,
scale             = "none", # otherwise numbers are changed
cellwidth         = 15,
cellheight        = 15,
# title
main              = main.title,
fontsize          = 14,
annotation        = dplyr::select(exptDesign, condition),
# rows
cluster_rows      = mat_cluster_rows,
treeheight_row    = 25, # default is 50
show_rownames     = TRUE,
labels_row        = rownames(exptDesign),
fontsize_row      = 9,
annotation_row    = annot_batch,
# cols
cluster_cols      = mat_cluster_cols,
treeheight_col    = 25,
show_colnames     = TRUE,
labels_col        = rownames(exptDesign),
fontsize_col      = 9,
angle_col         = 45,
# legends
legend_breaks     = c(bot, 1),
# tiles
color             = scico(255, palette='bamako'),
border_color      = 'grey80')
analysisObject = DESeq(exptObject)
plotDispEsts(analysisObject)
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
# add column with transcript lengths, turn GeneID rownames into column
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
# create matrix of TPM values per sample
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
# turn TPM into dataframe
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
# reduce TPM to the genes detected in the RNAseq samples
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
# test that the rows are still the same:
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
# test that there is information for all of them (e.g. no mismatch between the GTF files used)
cat(
cat('There are\t',nrow(rawCounts),
'\tgenes listed in `rawCounts`, and there are data for\t\t',
nrow(na.omit(rawCounts)), '\tof them.\n'),
cat('There are\t',nrow(normalisedCounts),
'\tgenes listed in `normalisedCounts`, and there are data for\t',
nrow(na.omit(normalisedCounts)), '\tof them.\n'),
cat('There are\t',nrow(tpmNormalisedCounts),
'\tgenes listed in `tpmNormalisedCounts`, and there are data for\t',
nrow(na.omit(tpmNormalisedCounts)), '\tof them.\n')
)
# for downstream use
saveRDS(rawCounts, 'output/rawCounts.RDS')
saveRDS(normalisedCounts, 'output/normalisedCounts.RDS')
saveRDS(tpmNormalisedCounts, 'output/tpmNormalisedCounts.RDS')
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", 'Control', condtn),
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
tests[[paste0('Control_vs_', condtn)]] <- deData
}
# add `rawCounts` to `tests`
tests <- rlist::list.append(tests, `Raw counts per gene per sample`=rawCounts)
# Supplementary data for publication
write_xlsx(tests, path='output/Table S3.xlsx')
targets$condition_md <- plyr::mapvalues(
targets$Condition,
from=unique(targets$Condition),
to=c('*da^RNAi^*', '*da^o|e^*', '*wild-type*', '*da:da^O\\E^*', '*scute^OE^*')
)
targets$condition_md <- factor(
targets$condition_md,
c('*wild-type*', '*da^o|e^*', '*da:da^O\\E^*','*da^RNAi^*', '*scute^OE^*')
)
saveRDS(targets, 'output/targets.RDS')
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'),
fig.align = 'center', fig.height = 5, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
# data
library(tibble)
# graphics
library(ggplot2)
library(ggthemes)       # italics in the figures
library(ggtext)         # italics in the figures
library(pheatmap)       # pretty heatmap
library(scico)          # scientific colormaps
library(ggrepel)        # to avoid overlapping text
# convenience
library(here);
setwd(here())
# get the data (fresh session)
targets <- readRDS('output/targets.RDS')
tpmNormalisedCounts <- readRDS('output/tpmNormalisedCounts.RDS')
# remove all rows that have no variance
tpmNormalisedCounts_pca <- tpmNormalisedCounts[
rowSums(tpmNormalisedCounts[-1] != tpmNormalisedCounts[[2]], na.rm = TRUE) != 0,
]
pca <- prcomp(t(tpmNormalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
summary(pca)
ggplot(scores,
aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
) +
geom_point(size=4) +
geom_point(size=2, colour='white', alpha=0.8) +
geom_text_repel(size=4, max.overlaps=Inf,
force_pull = -0.03, seed=42,
box.padding = 0.5,
point.padding = 0.5) +
scale_colour_discrete(name="condition") +
theme_bw() +
lims(x= c(-115, 175), y = c(-70, 70)) +
theme(legend.text=element_markdown(size=9))
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'),
fig.align = 'center', fig.height = 5, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
# bioinformatics
library(DESeq2)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # to handling gene/exon coordinates data
library(GenomicFeatures) # to handling gene/exon coordinates data
# data / plotting
library(ggplot2)
library(dplyr)
library(stringr)
library(pheatmap)        # pretty heatmaps
library(scico)           # scientific colour maps
library(dendsort)        # sort dendrograms
# convenience
library(writexl)
library(here)
setwd(here())
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
txdb <- makeTxDbFromGRanges(import('resources/Drosophila_melanogaster.BDGP6.28.101.gtf'))
# same release as the one used for mapping
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org")
# to update this: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
names(dlist) <- 'gene_symbol'
write.table(dlist, file="resources/gene_symbols.txt", col.names=NA)
targets <- read.table("input/targets.txt", header=TRUE, sep="\t")
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
if (file.exists( paste("input/dadasc/featurecounts/",
sampleID,
".featurecount", sep="") )){
fileContents <- read.table(paste("input/dadasc/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
} else {
fileContents <- read.table(paste("input/daoekd/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
}
rawData <- cbind(rawData, fileContents[,7])
}
colnames(rawData) <- paste(targets$Condition, targets$Replicate, targets$Batch, sep='_')
rownames(rawData) <- fileContents$Geneid
cpms <- edgeR::cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
colData = exptDesign,
design = ~ batch + condition)
exptObject$condition <- factor(exptObject$condition,
levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect( assay(vsd_Object),
batch=vsd_Object$batch,
design=model.matrix(~condition, colData(vsd_Object)) )
plotPCA(vsd_Object)
# this bit of code is a bit longer than it needs to
# as I was experimenting to get the heatmap closer to publication standard
# Compute the correlation values between samples
vsd_cor_Object <- cor(assay(vsd_Object))
# heatmap
main.title <- 'RNAseq sample correlations'
## get sorted clusters
sort_hclust <- function(x) as.hclust(dendsort(as.dendrogram(x)))
mat_cluster_cols <- hclust(dist(t(vsd_cor_Object)))
mat_cluster_cols <- sort_hclust(mat_cluster_cols)
mat_cluster_rows <- hclust(dist(vsd_cor_Object))
mat_cluster_rows <- sort_hclust(mat_cluster_rows)
## mark the batches
annot_batch <- data.frame(batch = ifelse(test = targets$Batch == 'a',
yes = 'batch A',
no = 'batch B'))
rownames(annot_batch) <- rownames(vsd_cor_Object)
## get minimum correlation value, rounded for the legend
bot <- ceiling(min(vsd_cor_Object)*100)/100
## plot
pheatmap(
# data
mat               = vsd_cor_Object,
scale             = "none", # otherwise numbers are changed
cellwidth         = 15,
cellheight        = 15,
# title
main              = main.title,
fontsize          = 14,
annotation        = dplyr::select(exptDesign, condition),
# rows
cluster_rows      = mat_cluster_rows,
treeheight_row    = 25, # default is 50
show_rownames     = TRUE,
labels_row        = rownames(exptDesign),
fontsize_row      = 9,
annotation_row    = annot_batch,
# cols
cluster_cols      = mat_cluster_cols,
treeheight_col    = 25,
show_colnames     = TRUE,
labels_col        = rownames(exptDesign),
fontsize_col      = 9,
angle_col         = 45,
# legends
legend_breaks     = c(bot, 1),
# tiles
color             = scico(255, palette='bamako'),
border_color      = 'grey80')
analysisObject = DESeq(exptObject)
plotDispEsts(analysisObject)
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
# add column with transcript lengths, turn GeneID rownames into column
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
# create matrix of TPM values per sample
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
# turn TPM into dataframe
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
# reduce TPM to the genes detected in the RNAseq samples
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
# test that the rows are still the same:
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
# test that there is information for all of them (e.g. no mismatch between the GTF files used)
cat(
cat('There are\t',nrow(rawCounts),
'\tgenes listed in `rawCounts`, and there are data for\t\t',
nrow(na.omit(rawCounts)), '\tof them.\n'),
cat('There are\t',nrow(normalisedCounts),
'\tgenes listed in `normalisedCounts`, and there are data for\t',
nrow(na.omit(normalisedCounts)), '\tof them.\n'),
cat('There are\t',nrow(tpmNormalisedCounts),
'\tgenes listed in `tpmNormalisedCounts`, and there are data for\t',
nrow(na.omit(tpmNormalisedCounts)), '\tof them.\n')
)
# for downstream use
saveRDS(rawCounts, 'output/rawCounts.RDS')
saveRDS(normalisedCounts, 'output/normalisedCounts.RDS')
saveRDS(tpmNormalisedCounts, 'output/tpmNormalisedCounts.RDS')
# to get a more informative naming for the samples:
targets$sampleIDs <- names(rawCounts)
# conditions to be tested
test_conditions <- unique( targets[targets$Condition != 'Control',]$Condition )
test_names <- paste0(rep('Control_vs_',length(test_conditions)),test_conditions)
tests <- as.list(rep(NA, length(test_names)))
names(tests) <- test_names
for (condtn in test_conditions) {
# get the Counts for those conditions
deData <- as.data.frame(results(analysisObject,
contrast=c("condition", 'Control', condtn),
pAdjustMethod="BH"))
# add column of ID
deData <- cbind(data.frame('ensemblGeneID'=rownames(deData)), deData)
# sort by pval
deData <- deData[order(deData$pvalue), ]
# add gene symbol column and reorder columns
deData <- merge(deData, dlist, by=0)
deData <- deData[,c(1,ncol(deData),2:(ncol(deData)-1))]
# save for later
saveRDS(deData, file=paste0("output/", 'Control_vs_', condtn, ".RDS"))
# save as Supplementary data for publication
tests[[paste0('Control_vs_', condtn)]] <- deData
}
# add `rawCounts` to `tests`
tests <- rlist::list.append(tests, `Raw counts per gene per sample`=rawCounts)
# Supplementary data for publication
write_xlsx(tests, path='output/Table S3.xlsx')
targets$condition_md <- plyr::mapvalues(
targets$Condition,
from=unique(targets$Condition),
to=c('*da^RNAi^*', '*da^OVEX^*', '*wild-type*', '*da:da^OVEX^*', '*scute^OVEX^*')
)
targets$condition_md <- factor(
targets$condition_md,
c('*wild-type*', '*da^OVEX^*', '*da:da^OVEX^*','*da^RNAi^*', '*scute^OVEX^*')
)
saveRDS(targets, 'output/targets.RDS')
head(rawCounts)
head(normalisedCounts)
head(tpmNormalisedCounts)
head(vsd_Object)
head(assay(vsd_Object))
# get the data (fresh session)
targets <- readRDS('output/targets.RDS')
tpmNormalisedCounts <- readRDS('output/tpmNormalisedCounts.RDS')
# remove all rows that have no variance
tpmNormalisedCounts_pca <- tpmNormalisedCounts[
rowSums(tpmNormalisedCounts[-1] != tpmNormalisedCounts[[2]], na.rm = TRUE) != 0, ]
# same for the other count datasets
normalisedCounts <- readRDS('output/normalisedCounts.RDS')
normalisedCounts_pca <- normalisedCounts[
rowSums(normalisedCounts[-1] != normalisedCounts[[2]], na.rm = TRUE) != 0, ]
rawCounts <- readRDS('output/rawCounts.RDS')
rawCounts_pca <- rawCounts[
rowSums(rawCounts[-1] != rawCounts[[2]], na.rm = TRUE) != 0, ]
pca <- prcomp(t(normalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
ggplot(scores,
aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
) +
geom_point(size=4) +
geom_point(size=2, colour='white', alpha=0.8) +
geom_text_repel(size=4, max.overlaps=Inf,
force_pull = -0.03, seed=42,
box.padding = 0.5,
point.padding = 0.5) +
scale_colour_discrete(name="condition") +
theme_bw() +
lims(x= c(-115, 175), y = c(-70, 70)) +
theme(legend.text=element_markdown(size=9))
pca <- prcomp(t(normalisedCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
ggplot(scores,
aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
) +
geom_point(size=4) +
geom_point(size=2, colour='white', alpha=0.8) +
geom_text_repel(size=4, max.overlaps=Inf,
force_pull = -0.03, seed=42,
box.padding = 0.5,
point.padding = 0.5) +
scale_colour_discrete(name="condition") +
theme_bw() +
theme(legend.text=element_markdown(size=9))
pca <- prcomp(t(rawCounts_pca), center=TRUE, scale=TRUE)
scores <- data.frame(targets$sampleIDs, pca$x[,1:2])
ggplot(scores,
aes(x = PC1, y = PC2, label=factor(targets$sampleIDs), colour=factor(targets$condition_md) )
) +
geom_point(size=4) +
geom_point(size=2, colour='white', alpha=0.8) +
geom_text_repel(size=4, max.overlaps=Inf,
force_pull = -0.03, seed=42,
box.padding = 0.5,
point.padding = 0.5) +
scale_colour_discrete(name="condition") +
theme_bw() +
theme(legend.text=element_markdown(size=9))
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
head(assay(vsd_Object))
head(normalisedCounts)
