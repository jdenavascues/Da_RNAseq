with(subset(df, external_gene_name %in% selected_genes & padj<.05 & log2FoldChange<(-1)),
textxy(log10(mean_tpm),
log2FoldChange,
labs=external_gene_name,
cex=0.9, font=2, col="#721f0f"))
plot()
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org") # update this to the latest: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
write.table(dlist, file="resources/gene_names.txt", col.names=NA)
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'),
fig.align = 'center', fig.height = 5, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
library(DESeq2)          # to normalise RNAseq count data and perform DEG analysis
library(edgeR)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # to handling gene/exon coordinates data
library(GenomicFeatures) # to handling gene/exon coordinates data
library(ggplot2)         # for making QC plots
library(dplyr)           # for handling data frames
library(stringr)         # for handling strings
library(pheatmap)        # to plot heatmap
library(here)
setwd(here())
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
txdb <- makeTxDbFromGRanges(import('resources/dmel-all-r6.50.gtf'))
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org") # update this to the latest: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
write.table(dlist, file="resources/gene_names.txt", col.names=NA)
txdb <- makeTxDbFromGRanges(import('resources/dmel-all-r6.50.gtf'))
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org") # update this to the latest: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
write.table(dlist, file="resources/gene_names.txt", col.names=NA)
targets <- read.table("resources/targets_batched.txt", header=TRUE, sep="\t")
targets
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
if (file.exists( paste("input/dadasc/featurecounts/",
sampleID,
".featurecount", sep="") )){
fileContents <- read.table(paste("input/dadasc/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
} else {
fileContents <- read.table(paste("input/daoekd/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
}
rawData <- cbind(rawData, fileContents[,7])
}
colnames(rawData) <- targets$sampleID
rownames(rawData) <- fileContents$Geneid
cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples (out of 6, originally)
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(
countData = rawData,
colData = exptDesign,
design = ~ condition)
exptObject <- DESeqDataSetFromMatrix(
countData = rawData,
colData = exptDesign,
design = ~ condition + batch)
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'),
fig.align = 'center', fig.height = 5, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
library(DESeq2)          # to normalise RNAseq count data and perform DEG analysis
library(edgeR)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # to handling gene/exon coordinates data
library(GenomicFeatures) # to handling gene/exon coordinates data
library(ggplot2)         # for making QC plots
library(dplyr)           # for handling data frames
library(stringr)         # for handling strings
library(pheatmap)        # to plot heatmap
library(here)
setwd(here())
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
txdb <- makeTxDbFromGRanges(import('resources/dmel-all-r6.50.gtf'))
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org") # update this to the latest: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
write.table(dlist, file="resources/gene_names.txt", col.names=NA)
targets <- read.table("resources/targets_batched.txt", header=TRUE, sep="\t")
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
if (file.exists( paste("input/dadasc/featurecounts/",
sampleID,
".featurecount", sep="") )){
fileContents <- read.table(paste("input/dadasc/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
} else {
fileContents <- read.table(paste("input/daoekd/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
}
rawData <- cbind(rawData, fileContents[,7])
}
colnames(rawData) <- targets$sampleID
rownames(rawData) <- fileContents$Geneid
cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples (out of 6, originally)
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(
countData = rawData,
colData = exptDesign,
design = ~ condition + batch)
exptObject
DESeq()
DESeq
head(rawData)
colData()
targets
head(exptObject)
levels(exptObject$condition)
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
colData = exptDesign,
design = ~ condition + batch)
exptObject$condition <- factor(exptObject$condition, levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
levels(exptObject$condition)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = select(exptDesign, condition))
select(exptDesign, condition)
select(exptDesign)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = select(exptDesign))
plotMA(results(DESeq(exptObject)))
vsd_cor_Object
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = select(exptDesign$condition))
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = select(exptDesign, c(condition, batch)))
exptDesign$condition
exptDesign$batch
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object)
exptDesign
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign)
analysisObject = DESeq(exptObject)
plotDispEsts(analysisObject)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE, cluster_cols=FALSE)
plotDispEsts(analysisObject)
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
saveRDS(tpmNormalisedCounts, 'daoekd_counts.RDS')
plotPCA(vsd_mat_Object, "Batch")
plotPCA
plotPCA(vsd_Object)
plotPCA(vsd_Object, "batch")
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_mat_Object), vsd_mat_Object$batch)
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_Object), vsd_Object$batch)
plotPCA(vsd, "batch")
plotPCA(vsd_Object, "batch")
plotPCA(vsd_Object)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_Object), vsd_Object$batch)
plotPCA(vsd_Object)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=FALSE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_Object), vsd_Object$batch)
plotPCA(vsd_Object)
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_Object), vsd_Object$batch)
plotPCA(vsd_Object)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE, cluster_cols=FALSE)
ggplot2::theme_set(ggpubr::theme_pubr(base_size=10))
knitr::opts_chunk$set(dev = c('png', 'cairo_pdf'),
fig.align = 'center', fig.height = 5, fig.width = 8.5,
pdf.options(encoding = "ISOLatin9.enc"),
fig.path='integration/figures/', warning=FALSE, message=FALSE)
library(DESeq2)          # to normalise RNAseq count data and perform DEG analysis
library(edgeR)
library(biomaRt)         # to annotate the final gene list with common gene names
library(rtracklayer)     # to handling gene/exon coordinates data
library(GenomicFeatures) # to handling gene/exon coordinates data
library(ggplot2)         # for making QC plots
library(dplyr)           # for handling data frames
library(stringr)         # for handling strings
library(pheatmap)        # to plot heatmap
library(here)
setwd(here())
tpm <- function(counts, lengths) {
return ((counts * 1e6) / (lengths * sum(counts/lengths,na.rm=TRUE)))
}
txdb <- makeTxDbFromGRanges(import('resources/dmel-all-r6.50.gtf'))
allTranscripts <- transcriptLengths(txdb)
allGeneIDs <- unique(allTranscripts$gene_id)
allGeneLengths <- as.data.frame(allTranscripts %>%
group_by(gene_id) %>%
summarize(max.tx_len = max(tx_len)) )
ensembl = useEnsembl(biomart = "ENSEMBL_MART_ENSEMBL",
dataset="dmelanogaster_gene_ensembl",
host = "https://oct2022.archive.ensembl.org") # update this to the latest: https://www.ensembl.org/Help/ArchiveRedirect
filters = listFilters(ensembl) # It defines filters in case you have a specific query
attributes = listAttributes(ensembl) #Defines the features that will be showed
dlist <- getBM(attributes=c('ensembl_gene_id', 'external_gene_name'), mart = ensembl)
rownames(dlist) <- dlist$ensembl_gene_id
dlist[1] <- NULL
write.table(dlist, file="resources/gene_names.txt", col.names=NA)
targets <- read.table("resources/targets_batched.txt", header=TRUE, sep="\t")
rawData <- NULL
# each column of rawData will contain the reads per gene of a sample
for (sampleID in targets$sampleID) {
if (file.exists( paste("input/dadasc/featurecounts/",
sampleID,
".featurecount", sep="") )){
fileContents <- read.table(paste("input/dadasc/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
} else {
fileContents <- read.table(paste("input/daoekd/featurecounts/",
sampleID, ".featurecount", sep=""),
sep="\t",
header=T)
}
rawData <- cbind(rawData, fileContents[,7])
}
colnames(rawData) <- targets$sampleID
rownames(rawData) <- fileContents$Geneid
cpms <- cpm(rawData)
keep <- rowSums(cpms > 1) >= 3 # detected in at least 3 samples (out of 6, originally)
rawData <- rawData[keep,]
exptDesign = data.frame(
row.names = colnames(rawData),
condition = targets$Condition,
batch = targets$Batch)
exptObject <- DESeqDataSetFromMatrix(countData = rawData,
colData = exptDesign,
design = ~ condition + batch)
exptObject$condition <- factor(exptObject$condition, levels = c("Control", "DaKD", "DaOE", "DaDaOE", "ScOE"))
# Transform the normalized counts
vsd_Object <- vst(exptObject, blind=TRUE)
plotPCA(vsd_Object)
assay(vsd_Object) <- limma::removeBatchEffect(assay(vsd_Object), vsd_Object$batch)
plotPCA(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign$condition,
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign[,condition],
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign[,conditions],
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign[conditions,],
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign[,'conditions'],
cluster_rows=FALSE, cluster_cols=FALSE)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = exptDesign,
cluster_rows=FALSE, cluster_cols=FALSE)
exptDesign
select(exptDesign, !batch)
select(exptDesign, !(batch))
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = dplyr::select(exptDesign, conditions),
cluster_rows=FALSE, cluster_cols=FALSE)
dplyr::select(exptDesign, conditions)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = dplyr::select(exptDesign, condition),
cluster_rows=FALSE, cluster_cols=FALSE)
# Extract the matrix of transformed counts
vsd_mat_Object <- assay(vsd_Object)
# Compute the correlation values between samples
vsd_cor_Object <- cor(vsd_mat_Object)
# Plot the heatmap
pheatmap(vsd_cor_Object, annotation = dplyr::select(exptDesign, condition),
cluster_rows=FALSE, cluster_cols=FALSE)
targets
targets[,c(Condition, Batch)]
targets[,c('Condition', 'Batch')]
colData <- targets[,c(Condition, Batch)]
colData <- targets[,c('Condition', 'Batch')]
mat <- assay(vsd_Object)
mm <- model.matrix(~condition, colData(vsd_Object))
colData <- targets[,c('Condition', 'Batch')]
rownames(colData) <- targets$sampleID
mat <- limma::removeBatchEffect(mat, batchh=vsd_Object$batch, design=mm)
assay(vsd_Object) <- mat
plotPCA(vsd_Object)
analysisObject = DESeq(exptObject)
plotDispEsts(analysisObject)
rawCounts <- as.data.frame(counts(analysisObject, normalized=FALSE))
normalisedCounts <- as.data.frame(counts(analysisObject, normalized=TRUE))
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
saveRDS(tpmNormalisedCounts, 'daoekd_counts.RDS')
rawDataWithLengths <- merge(allGeneLengths, rawCounts, by.x="gene_id", by.y="row.names", all=T)
rawCountData <- rawDataWithLengths[,colnames(rawCounts)]
rownames(rawCountData) <- rawDataWithLengths[,1]
tpmData <- NULL
for (colName in colnames(rawCountData)) {
tpmData <- cbind(tpmData, tpm(rawDataWithLengths[,colName], rawDataWithLengths$max.tx_len))
}
tpmData <- as.data.frame(tpmData)
colnames(tpmData) <- colnames(rawCounts)
rownames(tpmData) <- rawDataWithLengths[,1]
tpmNormalisedCounts <- tpmData[match(rownames(rawCounts), rownames(tpmData)), ]
if (!identical(rownames(rawCounts), rownames(normalisedCounts))) {
stop()
}
if (!identical(rownames(tpmNormalisedCounts), rownames(normalisedCounts))) {
stop()
}
saveRDS(tpmNormalisedCounts, 'batched_counts.RDS')
library(ggplot2)
library(ggthemes) # italics in the figures
library(ggtext) # italics in the figures
library(pheatmap)        # to plot heatmap
library(tibble)
library(here); setwd(here())
devtools::install_github("thomasp85/scico")
library(scico)
scico_palette_show(palettes = c("broc", "cork", "vik",
"lisbon", "tofino", "berlin",
"batlow", "roma"))
scico_palette_show(palettes = c("broc", "cork", "vik",
"lisbon", "tofino", "berlin",
"batlow", "roma"))
